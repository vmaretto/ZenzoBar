<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ZenzoBar Orders</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Firebase v9 SDK -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js';
        import { getFirestore, doc, setDoc, onSnapshot } from 'https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js';
        
        // üî• TUA CONFIGURAZIONE FIREBASE
        const firebaseConfig = {
            apiKey: "AIzaSyAlYaxfd7JScPfwayxUF6um5fbU2CQ8SWg",
            authDomain: "zenzobar-edbdc.firebaseapp.com", 
            projectId: "zenzobar-edbdc",
            storageBucket: "zenzobar-edbdc.firebasestorage.app",
            messagingSenderId: "408846717271",
            appId: "1:408846717271:web:53e2132f8370b9eb325612"
        };

        // Inizializza Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        
        // Rendi Firebase globale per l'app
        window.firebaseApp = app;
        window.firebaseDb = db;
        window.firebaseDoc = doc;
        window.firebaseSetDoc = setDoc;
        window.firebaseOnSnapshot = onSnapshot;
        
        console.log('üî• Firebase inizializzato con successo!');
        
        // Notifica che Firebase √® pronto
        window.dispatchEvent(new Event('firebaseReady'));
    </script>
</head>
<body>
    <div id="app">
        <div class="flex items-center justify-center min-h-screen">
            <div class="text-center">
                <div class="animate-spin rounded-full h-32 w-32 border-b-2 border-orange-500 mx-auto"></div>
                <p class="mt-4 text-gray-600">Caricamento ZenzoBar...</p>
            </div>
        </div>
    </div>
    
    <!-- Modal per note -->
    <div id="noteModal" class="fixed inset-0 bg-black bg-opacity-50 hidden z-50 flex items-center justify-center">
        <div class="bg-white rounded-lg p-6 w-96 max-w-full mx-4">
            <h3 class="text-lg font-bold mb-4">üìù Aggiungi Nota</h3>
            <div id="noteItemInfo" class="mb-4 p-3 bg-gray-50 rounded"></div>
            <textarea id="noteInput" rows="3" class="w-full border rounded p-3 mb-4" placeholder="Scrivi qui la tua nota..."></textarea>
            <div class="flex gap-3 justify-end">
                <button onclick="app.cancelNote()" class="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600">
                    Annulla
                </button>
                <button onclick="app.saveNote()" class="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700">
                    ‚úÖ Salva Nota
                </button>
            </div>
        </div>
    </div>

    <!-- Modal per ordine libero -->
    <div id="freeOrderModal" class="fixed inset-0 bg-black bg-opacity-50 hidden z-50 flex items-center justify-center">
        <div class="bg-white rounded-lg p-6 w-96 max-w-full mx-4">
            <h3 class="text-lg font-bold mb-4">üÜì Ordine Libero</h3>
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium mb-2">Nome Articolo:</label>
                    <input type="text" id="freeItemName" class="w-full border rounded p-3" placeholder="Es: Acqua extra, Pane...">
                </div>
                <div>
                    <label class="block text-sm font-medium mb-2">Prezzo (‚Ç¨):</label>
                    <input type="number" step="0.1" min="0" id="freeItemPrice" class="w-full border rounded p-3" placeholder="0.00">
                </div>
                <div>
                    <label class="block text-sm font-medium mb-2">Note (opzionale):</label>
                    <textarea id="freeItemNote" rows="2" class="w-full border rounded p-3" placeholder="Note aggiuntive..."></textarea>
                </div>
            </div>
            <div class="flex gap-3 justify-end mt-6">
                <button onclick="app.cancelFreeOrder()" class="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600">
                    Annulla
                </button>
                <button onclick="app.saveFreeOrder()" class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">
                    ‚ûï Aggiungi
                </button>
            </div>
        </div>
    </div>
    
    <script>
        // Firebase Service
        class FirebaseService {
            constructor() {
                this.db = null;
                this.listeners = [];
                this.isInitialized = false;
                
                // Attendi che Firebase sia caricato
                if (window.firebaseDb) {
                    this.initializeFirebase();
                } else {
                    window.addEventListener('firebaseReady', () => {
                        this.initializeFirebase();
                    });
                }
            }
            
            initializeFirebase() {
                this.db = window.firebaseDb;
                this.isInitialized = true;
                console.log('üî• FirebaseService pronto!');
                
                // Notifica i listeners che Firebase √® pronto
                this.listeners.forEach(listener => {
                    this.setupRealListener(listener);
                });
            }
            
            async setupRealListener(listener) {
                if (!this.isInitialized || !this.db) return;
                
                try {
                    const docRef = window.firebaseDoc(this.db, 'zenzobar', listener.path);
                    
                    const unsubscribe = window.firebaseOnSnapshot(docRef, (docSnap) => {
                        console.log(`üî• Firebase update per ${listener.path}`);
                        const data = docSnap.exists() ? docSnap.data().value : this.getDefaultValue(listener.path);
                        listener.callback(data);
                    }, (error) => {
                        console.error(`‚ùå Errore listener Firebase per ${listener.path}:`, error);
                    });
                    
                    listener.unsubscribe = unsubscribe;
                } catch (error) {
                    console.error('Errore setup listener Firebase:', error);
                }
            }
            
            getDefaultValue(path) {
                switch(path) {
                    case 'activeOrders':
                    case 'orderHistory':
                    case 'tables':
                        return [];
                    case 'orders':
                        return {};
                    default:
                        return {};
                }
            }
            
            onSnapshot(path, callback) {
                const listener = { path, callback };
                this.listeners.push(listener);
                
                if (this.isInitialized) {
                    this.setupRealListener(listener);
                } else {
                    // Se Firebase non √® ancora pronto, restituisci valori default
                    const currentData = this.getDefaultValue(path);
                    callback(currentData);
                }
                
                return () => {
                    this.listeners = this.listeners.filter(l => l.callback !== callback);
                    if (listener.unsubscribe) {
                        listener.unsubscribe();
                    }
                };
            }
            
            async update(path, newData) {
                console.log(`üîÑ Aggiornamento: ${path}`, newData);
                
                if (this.isInitialized && this.db) {
                    try {
                        const docRef = window.firebaseDoc(this.db, 'zenzobar', path);
                        await window.firebaseSetDoc(docRef, { value: newData, timestamp: new Date() });
                        console.log(`üî• Firebase aggiornato: ${path}`);
                    } catch (error) {
                        console.error(`‚ùå Errore aggiornamento Firebase per ${path}:`, error);
                    }
                } else {
                    console.log('Firebase non ancora pronto, aggiornamento in coda...');
                }
            }
            
            getConnectionState() {
                return this.isInitialized && navigator.onLine;
            }
        }
        
        const firebaseService = new FirebaseService();
        
        // Funzioni globali per evitare problemi di sintassi
        window.toggleCat = function(category) {
            console.log('üîÑ Toggle categoria globale:', category);
            if (window.app && window.app.toggleCategory) {
                window.app.toggleCategory(category);
            } else {
                console.error('‚ùå App non disponibile');
            }
        };
        
        window.toggleCatByIndex = function(categoryIndex) {
            console.log('üîÑ Toggle categoria per indice:', categoryIndex);
            console.log('üîç window.app esiste?', !!window.app);
            console.log('üîç window.app.menuCategories esiste?', !!(window.app && window.app.menuCategories));
            
            if (window.app && window.app.menuCategories) {
                const categories = Object.keys(window.app.menuCategories);
                console.log('üìÇ Tutte le categorie:', categories);
                console.log('üìÇ Indice richiesto:', categoryIndex);
                
                const category = categories[categoryIndex];
                console.log('üìÇ Categoria trovata:', category);
                
                if (category && window.app.toggleCategory) {
                    console.log('‚úÖ Chiamando toggleCategory per:', category);
                    window.app.toggleCategory(category);
                } else {
                    console.error('‚ùå Categoria non trovata per indice:', categoryIndex);
                    console.error('‚ùå toggleCategory esiste?', !!(window.app && window.app.toggleCategory));
                }
            } else {
                console.error('‚ùå App o menuCategories non disponibile');
                console.error('‚ùå window.app:', window.app);
                console.error('‚ùå menuCategories:', window.app ? window.app.menuCategories : 'N/A');
            }
        };
        
        window.expandAll = function() {
            console.log('üìÇ Espandi tutto chiamata');
            if (window.app && window.app.expandAllCategories) {
                console.log('‚úÖ Chiamando expandAllCategories');
                window.app.expandAllCategories();
            } else {
                console.error('‚ùå expandAllCategories non disponibile');
            }
        };
        
        window.collapseAll = function() {
            console.log('üìÅ Chiudi tutto chiamata');
            if (window.app && window.app.collapseAllCategories) {
                console.log('‚úÖ Chiamando collapseAllCategories');
                window.app.collapseAllCategories();
            } else {
                console.error('‚ùå collapseAllCategories non disponibile');
            }
        };
        
        // ZenzoBar App
        class ZenzoBarApp {
            constructor() {
                this.state = {
                    currentView: 'tables',
                    selectedTable: null,
                    orders: {},
                    orderHistory: [],
                    activeOrders: [],
                    showSettings: false,
                    tableCount: 8,
                    customTables: [],
                    editingTable: null,
                    isOnline: true,
                    syncStatus: 'Inizializzazione...',
                    customMenuData: null, // Menu caricato da CSV
                    expandedCategories: {}, // Categorie espanse nel menu
                    // Stati per note e ordini liberi
                    currentNoteItem: null,
                    currentNoteIndex: null
                };
                
                this.init();
            }
            
            init() {
                this.setupFirebaseListeners();
                this.render();
                
                // Connection check
                setInterval(() => {
                    const online = firebaseService.getConnectionState();
                    this.setState({ isOnline: online });
                    if (!online) {
                        this.setState({ syncStatus: 'üî¥ Offline' });
                    }
                }, 5000);
            }
            
            setupFirebaseListeners() {
                this.setState({ syncStatus: 'üîÑ Connessione Firebase...' });
                
                try {
                    const unsubscribeOrders = firebaseService.onSnapshot('orders', (data) => {
                        console.log('üì® Ricevuti orders:', data);
                        // ‚úÖ IMPORTANTE: Non sovrascrivere expandedCategories!
                        this.setState({ 
                            orders: data || {}, 
                            syncStatus: 'üî• Sincronizzato Firebase'
                            // NON includere expandedCategories qui
                        });
                    });

                    const unsubscribeActive = firebaseService.onSnapshot('activeOrders', (data) => {
                        console.log('üì® Ricevuti activeOrders:', data);
                        // ‚úÖ IMPORTANTE: Preserva expandedCategories
                        this.setState({ 
                            activeOrders: Array.isArray(data) ? data : []
                            // NON sovrascrivere altri stati
                        });
                    });

                    const unsubscribeHistory = firebaseService.onSnapshot('orderHistory', (data) => {
                        console.log('üì® Ricevuti orderHistory:', data);
                        this.setState({ orderHistory: Array.isArray(data) ? data : [] });
                    });

                    const unsubscribeTables = firebaseService.onSnapshot('tables', (data) => {
                        console.log('üì® Ricevuti tables:', data);
                        if (Array.isArray(data) && data.length > 0) {
                            this.setState({ customTables: data });
                        }
                    });

                    const unsubscribeMenu = firebaseService.onSnapshot('menuData', (data) => {
                        console.log('üì® Ricevuti menuData:', data);
                        this.setState({ customMenuData: data });
                    });
                    
                    // ‚úÖ NON sincronizzare expandedCategories con Firebase
                    // Mantieni solo in memoria locale per performance
                    
                } catch (error) {
                    console.error('Errore setup Firebase listeners:', error);
                    this.setState({ syncStatus: '‚ùå Errore connessione' });
                }
            }
            
            setState(newState) {
                console.log('üîÑ setState chiamata', Object.keys(newState));
                
                // ‚úÖ PROTEZIONE: Preserva sempre expandedCategories se non specificato
                const oldExpandedCategories = this.state.expandedCategories;
                this.state = { ...this.state, ...newState };
                
                // ‚úÖ Se expandedCategories non era nel newState, ripristinalo
                if (!newState.hasOwnProperty('expandedCategories')) {
                    this.state.expandedCategories = oldExpandedCategories;
                }
                
                console.log('üìä Stato expandedCategories preservato:', this.state.expandedCategories);
                this.render();
            }
            
            // ‚úÖ METODO RENDER - FONDAMENTALE PER AGGIORNARE IL DOM
            render() {
                console.log('üé® render() chiamata, vista corrente:', this.state.currentView);
                console.log('üé® expandedCategories nel render:', this.state.expandedCategories);
                
                const appElement = document.getElementById('app');
                if (!appElement) {
                    console.error('‚ùå Elemento #app non trovato!');
                    return;
                }
                
                let content = '';
                
                switch(this.state.currentView) {
                    case 'tables':
                        content = this.renderTableView();
                        break;
                    case 'menu':
                        content = this.renderMenuView();
                        break;
                    case 'kitchen':
                        content = this.renderKitchenView();
                        break;
                    case 'history':
                        content = this.renderHistoryView();
                        break;
                    default:
                        content = this.renderTableView();
                }
                
                appElement.innerHTML = content;
                console.log('‚úÖ render() completata, DOM aggiornato');
            }
            
            // Menu categories - usa CSV se disponibile, altrimenti menu di default
            get menuCategories() {
                // Se c'√® un menu personalizzato da CSV, usalo
                if (this.state.customMenuData) {
                    return this.state.customMenuData;
                }
                
                // Altrimenti usa il menu di default
                return {
                    "Cocktail Analcolico": [
                        { id: 1, name: "Acqua Rinfrescante allo Zenzero", price: 6, ingredients: "Zenzero fresco Limone Miele Acqua fredda", description: "Fresco, dissetante, con le note pungenti dello zenzero." },
                        { id: 2, name: "Zenzapero", price: 6, ingredients: "Bevanda naturale allo zenzero Acqua tonica Zenzero fresco", description: "" },
                        { id: 3, name: "Hulky", price: 7, ingredients: "Kiwi Succo di mela Tonica Basilico fresco", description: "Verde brillante, carattere fresco. Mix energico e botanico." },
                        { id: 4, name: "Tropicana", price: 7, ingredients: "Succo Ananas Sciroppo di Cocco Succo Arancia", description: "Un sorso d'estate: ananas, cocco, arancia e tonica." }
                    ],
                    "Bevande": [
                        { id: 5, name: "Caff√®", price: 1.2, ingredients: "Caff√® in grani, acqua", description: "Miscela dal gusto pieno e rotondo." },
                        { id: 6, name: "Cappuccino", price: 1.5, ingredients: "Latte fresco, caff√®", description: "Un abbraccio caldo per iniziare la giornata." },
                        { id: 7, name: "Acqua naturale", price: 1, ingredients: "Acqua", description: "Acqua sempre disponibile." },
                        { id: 8, name: "Acqua gassata", price: 1, ingredients: "Acqua", description: "Acqua frizzante sempre disponibile." },
                        { id: 9, name: "Succo artigianale Ananas", price: 5, ingredients: "Ananas", description: "Preparato fresco ogni giorno." },
                        { id: 10, name: "Succo artigianale Mela", price: 5, ingredients: "Mela verde", description: "Solo mele fresche, lavorate da noi con cura." },
                        { id: 11, name: "Kombucha Cedro", price: 4.5, ingredients: "Acqua t√® nero Zucchero Coltura di Kombucha", description: "Cedro aspro, aromatico, irresistibile." },
                        { id: 12, name: "Smoothie Fragole", price: 5, ingredients: "Fragole e latte", description: "Cremoso, fresco, genuino." }
                    ],
                    "Cocktail": [
                        { id: 13, name: "CHIOSCO AL MARE", price: 15, ingredients: "Gin dry Vermouth bianco Cetriolo Lime", description: "Il nostro cocktail signature. Botanico e pulito." },
                        { id: 14, name: "Ginger Mule Light", price: 10, ingredients: "Vodka infusa allo zenzero Lime Ginger beer", description: "Classico con spirito Zenzo." },
                        { id: 15, name: "THE SALT", price: 15, ingredients: "Gin Artigianale Lime Sale della Cornovaglia", description: "Creato da Paolo Santoro. Sapido e vibrante." },
                        { id: 16, name: "Ginger Vodka & Tonic", price: 10, ingredients: "Vodka infusa allo zenzero Acqua tonica premium", description: "Essenziale, ma con carattere." }
                    ],
                    "Panino": [
                        { id: 17, name: "Calamarino", price: 6, ingredients: "Calamaro scottato zucchine grigliate menta", description: "Tenero, profumato. Estate pura in un morso." },
                        { id: 18, name: "Salmon Zeta", price: 6, ingredients: "Salmone affumicato avocado cipolla rossa", description: "Nordico, tropicale e Zenzo." },
                        { id: 19, name: "Fresco Zeta", price: 6, ingredients: "Avocado zenzero carote lattughino", description: "Completamente vegetale. Freschezza al 100%." }
                    ],
                    "Dolce": [
                        { id: 20, name: "Torta Zenzo Bar", price: 4, ingredients: "Pan di Spagna speziato crema diplomatica", description: "La torta firma di Zenzo Bar." },
                        { id: 21, name: "Cheesecake allo zenzero", price: 4, ingredients: "Formaggio spalmabile zenzero fresco", description: "Equilibrio tra cremosit√† e piccante." }
                    ]
                };
            }
            
            generateTableLayout(count) {
                const tables = [];
                for (let i = 0; i < count; i++) {
                    const seats = i % 3 === 0 ? 6 : i % 2 === 0 ? 4 : 2;
                    tables.push({ id: i + 1, number: i + 1, seats: seats });
                }
                return tables;
            }
            
            get tables() {
                return this.state.customTables.length > 0 ? this.state.customTables : this.generateTableLayout(this.state.tableCount);
            }
            
            getCurrentOrder() {
                return this.state.orders[this.state.selectedTable] || [];
            }

            // ‚úÖ METODI PER NOTE
            showNoteModal(item, orderIndex = null) {
                console.log('üìù Mostra modal nota per:', item.name, 'index:', orderIndex);
                
                this.state.currentNoteItem = item;
                this.state.currentNoteIndex = orderIndex;
                
                // Mostra info articolo
                const noteItemInfo = document.getElementById('noteItemInfo');
                noteItemInfo.innerHTML = `
                    <div class="font-medium">${item.name}</div>
                    <div class="text-sm text-gray-600">‚Ç¨${item.price.toFixed(2)}</div>
                `;
                
                // Se stiamo modificando una nota esistente, pre-riempi il campo
                const noteInput = document.getElementById('noteInput');
                if (orderIndex !== null) {
                    const currentOrder = this.getCurrentOrder();
                    const existingNote = currentOrder[orderIndex]?.note || '';
                    noteInput.value = existingNote;
                } else {
                    noteInput.value = '';
                }
                
                // Mostra modal
                document.getElementById('noteModal').classList.remove('hidden');
                noteInput.focus();
            }

            cancelNote() {
                console.log('‚ùå Annulla nota');
                document.getElementById('noteModal').classList.add('hidden');
                this.state.currentNoteItem = null;
                this.state.currentNoteIndex = null;
            }

            async saveNote() {
                const noteInput = document.getElementById('noteInput');
                const note = noteInput.value.trim();
                
                console.log('üíæ Salva nota:', note);
                
                if (this.state.currentNoteIndex !== null) {
                    // Modifica nota esistente
                    await this.updateItemNote(this.state.currentNoteIndex, note);
                } else {
                    // Aggiungi nuovo item con nota
                    await this.addToOrder(this.state.currentNoteItem, note);
                }
                
                this.cancelNote();
            }

            async updateItemNote(orderIndex, note) {
                const currentOrder = this.getCurrentOrder();
                const updatedOrder = [...currentOrder];
                updatedOrder[orderIndex] = { ...updatedOrder[orderIndex], note: note };
                
                const updatedTableOrders = {
                    ...this.state.orders,
                    [this.state.selectedTable]: updatedOrder
                };
                
                this.setState({ orders: updatedTableOrders });
                await firebaseService.update('orders', updatedTableOrders);
            }

            // ‚úÖ METODI PER ORDINE LIBERO
            showFreeOrderModal() {
                console.log('üÜì Mostra modal ordine libero');
                
                // Reset campi
                document.getElementById('freeItemName').value = '';
                document.getElementById('freeItemPrice').value = '';
                document.getElementById('freeItemNote').value = '';
                
                // Mostra modal
                document.getElementById('freeOrderModal').classList.remove('hidden');
                document.getElementById('freeItemName').focus();
            }

            cancelFreeOrder() {
                console.log('‚ùå Annulla ordine libero');
                document.getElementById('freeOrderModal').classList.add('hidden');
            }

            async saveFreeOrder() {
                const name = document.getElementById('freeItemName').value.trim();
                const price = parseFloat(document.getElementById('freeItemPrice').value) || 0;
                const note = document.getElementById('freeItemNote').value.trim();
                
                if (!name) {
                    alert('‚ùå Inserisci il nome dell\'articolo');
                    return;
                }

                if (price <= 0) {
                    alert('‚ùå Inserisci un prezzo valido');
                    return;
                }

                console.log('üíæ Salva ordine libero:', { name, price, note });

                // Crea item personalizzato con ID univoco
                const freeItem = {
                    id: `free_${Date.now()}`,
                    name: name,
                    price: price,
                    ingredients: '',
                    description: 'Ordine libero',
                    isFreeOrder: true
                };

                await this.addToOrder(freeItem, note);
                this.cancelFreeOrder();
            }
            
            async addToOrder(item, note = '') {
                const currentOrder = this.getCurrentOrder();
                
                // Se ha una nota o √® un ordine libero, aggiungi sempre come nuovo item
                if (note || item.isFreeOrder) {
                    const newItem = { 
                        ...item, 
                        quantity: 1, 
                        note: note,
                        uniqueId: `${item.id}_${Date.now()}`
                    };
                    
                    const updatedTableOrders = {
                        ...this.state.orders,
                        [this.state.selectedTable]: [...currentOrder, newItem]
                    };
                    
                    this.setState({ orders: updatedTableOrders });
                    await firebaseService.update('orders', updatedTableOrders);
                    return;
                }

                // Logica normale per item senza note
                const existingItem = currentOrder.find(orderItem => 
                    orderItem.id === item.id && !orderItem.note
                );
                
                const updatedTableOrders = {
                    ...this.state.orders,
                    [this.state.selectedTable]: existingItem
                        ? currentOrder.map(orderItem =>
                            orderItem.id === item.id && !orderItem.note
                                ? { ...orderItem, quantity: orderItem.quantity + 1 }
                                : orderItem
                          )
                        : [...currentOrder, { ...item, quantity: 1, note: '' }]
                };
                
                this.setState({ orders: updatedTableOrders });
                await firebaseService.update('orders', updatedTableOrders);
            }
            
            async removeFromOrder(orderIndex) {
                const currentOrder = this.getCurrentOrder();
                const item = currentOrder[orderIndex];
                
                if (item.quantity > 1) {
                    // Diminuisci quantit√†
                    const updatedOrder = [...currentOrder];
                    updatedOrder[orderIndex] = { ...item, quantity: item.quantity - 1 };
                    
                    const updatedTableOrders = {
                        ...this.state.orders,
                        [this.state.selectedTable]: updatedOrder
                    };
                    
                    this.setState({ orders: updatedTableOrders });
                    await firebaseService.update('orders', updatedTableOrders);
                } else {
                    // Rimuovi completamente
                    const updatedOrder = currentOrder.filter((_, index) => index !== orderIndex);
                    
                    const updatedTableOrders = {
                        ...this.state.orders,
                        [this.state.selectedTable]: updatedOrder
                    };
                    
                    this.setState({ orders: updatedTableOrders });
                    await firebaseService.update('orders', updatedTableOrders);
                }
            }
            
            calculateTotal() {
                return this.getCurrentOrder().reduce((total, item) => total + (item.price * item.quantity), 0);
            }
            
            async printOrder() {
                const currentOrder = this.getCurrentOrder();
                if (currentOrder.length === 0) {
                    alert('Nessun articolo nell\'ordine!');
                    return;
                }

                this.setState({ syncStatus: 'üîÑ Invio in cucina...' });
                
                try {
                    const newOrder = {
                        id: Date.now(),
                        tableNumber: this.state.selectedTable,
                        items: [...currentOrder],
                        total: this.calculateTotal(),
                        timestamp: new Date(),
                        state: 'sent',
                        isModified: false,
                        version: 1
                    };
                    
                    const updatedActiveOrders = [...this.state.activeOrders, newOrder];
                    this.setState({ activeOrders: updatedActiveOrders });
                    await firebaseService.update('activeOrders', updatedActiveOrders);
                    
                    const clearedOrders = { ...this.state.orders };
                    delete clearedOrders[this.state.selectedTable];
                    this.setState({ orders: clearedOrders });
                    await firebaseService.update('orders', clearedOrders);
                    
                    this.setState({ syncStatus: 'üî• Sincronizzato Firebase' });
                    alert('‚úÖ ORDINE INVIATO IN CUCINA!');
                    this.setState({ currentView: 'tables' });
                } catch (error) {
                    this.setState({ syncStatus: '‚ùå Errore invio' });
                    alert('‚ùå Errore durante l\'invio in cucina. Riprova.');
                }
            }
            
            // ‚úÖ METODO TOGGLE CATEGORIA - VERSIONE ROBUSTA 
            toggleCategory(category) {
                console.log('üîÑ ===== TOGGLE CATEGORIA =====');
                console.log('üìÇ Categoria:', category);
                console.log('üìä Stato attuale expandedCategories:', this.state.expandedCategories);
                console.log('üìä Categoria attualmente espansa?', this.state.expandedCategories[category]);
                
                const currentExpanded = this.state.expandedCategories[category] || false;
                const newExpanded = !currentExpanded;
                
                console.log('üîÑ Cambio stato:', currentExpanded, '‚Üí', newExpanded);
                
                // ‚úÖ AGGIORNAMENTO ESPLICITO - Solo expandedCategories
                const newExpandedCategories = {
                    ...this.state.expandedCategories,
                    [category]: newExpanded
                };
                
                console.log('üìä Nuovo stato completo expandedCategories:', newExpandedCategories);
                
                // ‚úÖ setState con SOLO expandedCategories per evitare conflitti
                this.setState({ expandedCategories: newExpandedCategories });
                
                console.log('‚úÖ ===== TOGGLE COMPLETATO =====');
            }

            expandAllCategories() {
                console.log('üìÇ ===== ESPANDI TUTTO =====');
                const allCategories = Object.keys(this.menuCategories);
                console.log('üìÇ Categorie trovate:', allCategories);
                
                const newExpandedCategories = {};
                allCategories.forEach(category => {
                    newExpandedCategories[category] = true;
                });
                
                console.log('üìÇ Nuovo stato (tutto espanso):', newExpandedCategories);
                
                // ‚úÖ Aggiorna SOLO expandedCategories
                this.setState({ expandedCategories: newExpandedCategories });
                
                console.log('‚úÖ ===== ESPANDI TUTTO COMPLETATO =====');
            }

            collapseAllCategories() {
                console.log('üìÅ ===== CHIUDI TUTTO =====');
                console.log('üìÅ Stato precedente:', this.state.expandedCategories);
                
                // ‚úÖ Reset completo delle categorie
                this.setState({ expandedCategories: {} });
                
                console.log('üìÅ Nuovo stato: {}');
                console.log('‚úÖ ===== CHIUDI TUTTO COMPLETATO =====');
            }

            closeOrderFromKitchen(orderId) {
                const orderToClose = this.state.activeOrders.find(order => order.id == orderId);
                
                if (!orderToClose) {
                    alert('‚ùå Ordine non trovato!');
                    return;
                }

                const closedOrder = {
                    ...orderToClose,
                    state: 'paid',
                    closedAt: new Date(),
                    closedBy: 'kitchen'
                };
                
                const updatedHistory = [closedOrder, ...this.state.orderHistory];
                const updatedActiveOrders = this.state.activeOrders.filter(order => order.id != orderId);
                
                this.setState({ 
                    orderHistory: updatedHistory,
                    activeOrders: updatedActiveOrders
                });
                
                firebaseService.update('orderHistory', updatedHistory);
                firebaseService.update('activeOrders', updatedActiveOrders);
                
                alert(`‚úÖ Tavolo ${orderToClose.tableNumber} incassato e liberato!`);
            }

            closeOrderFromWaiter(tableNumber) {
                const orderToClose = this.state.activeOrders.find(order => order.tableNumber == tableNumber);
                
                if (!orderToClose) {
                    alert('‚ùå Nessun ordine attivo per questo tavolo!');
                    return;
                }

                const confirmMsg = `‚ö†Ô∏è LIBERARE TAVOLO ${tableNumber}?\n\nATTENZIONE: Confermi che il cliente ha PAGATO?\n\nOrdine: ‚Ç¨${orderToClose.total.toFixed(2)}\nArticoli: ${orderToClose.items.reduce((sum, item) => sum + item.quantity, 0)}\n\nClicca OK solo se il cliente ha gi√† pagato.`;
                
                if (!window.confirm(confirmMsg)) {
                    return;
                }

                const closedOrder = {
                    ...orderToClose,
                    state: 'paid',
                    closedAt: new Date(),
                    closedBy: 'waiter'
                };
                
                const updatedHistory = [closedOrder, ...this.state.orderHistory];
                const updatedActiveOrders = this.state.activeOrders.filter(order => order.id !== orderToClose.id);
                
                this.setState({
                    orderHistory: updatedHistory,
                    activeOrders: updatedActiveOrders
                });
                
                firebaseService.update('orderHistory', updatedHistory);
                firebaseService.update('activeOrders', updatedActiveOrders);
                
                alert(`‚úÖ Tavolo ${tableNumber} liberato dal cameriere!`);
            }
            
            renderHistoryView() {
                return `
                    <div class="p-6">
                        <div class="flex justify-between items-center mb-6">
                            <h1 class="text-2xl font-bold text-gray-800">Storico Ordini Chiusi</h1>
                            <button onclick="app.setState({currentView: 'tables'})" class="flex items-center gap-2 px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700">
                                ‚úï Chiudi
                            </button>
                        </div>
                        
                        ${this.state.orderHistory.length === 0 ? `
                            <div class="text-center text-gray-500 mt-12">
                                <div class="text-6xl mb-4">üïê</div>
                                <p>Nessun ordine chiuso oggi</p>
                                <p class="text-sm text-gray-400 mt-2">Gli ordini pagati appariranno qui</p>
                            </div>
                        ` : `
                            <div class="space-y-4">
                                ${this.state.orderHistory.map(order => `
                                    <div class="bg-white rounded-lg shadow p-4 border">
                                        <div class="flex justify-between items-start mb-3">
                                            <div>
                                                <h3 class="font-bold text-lg">Tavolo ${order.tableNumber}</h3>
                                                <p class="text-gray-600 text-sm">Ordinato: ${new Date(order.timestamp).toLocaleString('it-IT')}</p>
                                                <p class="text-gray-600 text-sm">Chiuso: ${new Date(order.closedAt).toLocaleString('it-IT')}</p>
                                                <p class="text-blue-600 text-sm font-medium">
                                                    Incassato da: ${order.closedBy === 'kitchen' ? 'üë®‚Äçüç≥ Cucina' : 'üë§ Cameriere'}
                                                </p>
                                            </div>
                                            <div class="text-right">
                                                <div class="text-2xl font-bold text-green-600">‚Ç¨${order.total.toFixed(2)}</div>
                                                <div class="text-sm text-gray-500">${order.items.reduce((sum, item) => sum + item.quantity, 0)} articoli</div>
                                                <div class="text-xs text-green-600 font-medium mt-1">üí∞ PAGATO</div>
                                            </div>
                                        </div>
                                        
                                        <div class="border-t pt-3">
                                            ${order.items.map(item => `
                                                <div class="flex justify-between text-sm mb-1">
                                                    <span>${item.quantity}x ${item.name}${item.note ? ` (${item.note})` : ''}</span>
                                                    <span>‚Ç¨${(item.price * item.quantity).toFixed(2)}</span>
                                                </div>
                                            `).join('')}
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        `}
                    </div>
                `;
            }

            async loadMenuFromCSV(file = null) {
                console.log('üöÄ INIZIO loadMenuFromCSV, file:', file ? 'Caricato dall\'utente' : 'File predefinito');
                
                try {
                    let csvContent;
                    
                    if (file) {
                        console.log('üìÇ Lettura file utente...');
                        csvContent = await new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onload = e => resolve(e.target.result);
                            reader.onerror = reject;
                            reader.readAsText(file, 'utf-8');
                        });
                        console.log('‚úÖ File utente letto, lunghezza:', csvContent.length);
                    } else {
                        console.log('üìÑ Tentativo lettura file predefinito...');
                        try {
                            csvContent = await window.fs.readFile('Menu29Giu copia.csv', { encoding: 'utf8' });
                            console.log('‚úÖ Menu29Giu copia.csv letto, lunghezza:', csvContent.length);
                        } catch (error) {
                            console.log('‚ö†Ô∏è Menu29Giu copia.csv non trovato, provo Menu29Giu.csv...');
                            try {
                                csvContent = await window.fs.readFile('Menu29Giu.csv', { encoding: 'utf8' });
                                console.log('‚úÖ Menu29Giu.csv letto, lunghezza:', csvContent.length);
                            } catch (error2) {
                                console.error('‚ùå Nessun file CSV trovato:', error2);
                                alert('‚ùå File CSV non trovato. Seleziona un file CSV da caricare.');
                                return;
                            }
                        }
                    }
                    
                    console.log('üîß Inizio parsing CSV...');
                    
                    // PARSER DEFINITIVO che gestisce virgolette multi-riga
                    function parseCSVCorrectly(content) {
                        console.log('üìä Parser avviato, contenuto lunghezza:', content.length);
                        
                        const normalized = content.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
                        const allLines = normalized.split('\n');
                        
                        console.log(`üìÑ Righe totali nel file: ${allLines.length}`);
                        console.log(`üìÑ Prima riga: "${allLines[0]}"`);
                        
                        // Ricostruisci le righe complete gestendo le virgolette
                        const completeLines = [];
                        let currentRecord = '';
                        let insideQuotes = false;
                        
                        for (let i = 0; i < allLines.length; i++) {
                            const line = allLines[i];
                            
                            if (currentRecord) {
                                currentRecord += '\n' + line;
                            } else {
                                currentRecord = line;
                            }
                            
                            // Conta virgolette nella riga corrente completa
                            const quoteCount = (currentRecord.match(/"/g) || []).length;
                            insideQuotes = quoteCount % 2 === 1;
                            
                            // Se non siamo dentro virgolette e abbiamo contenuto, la riga √® completa
                            if (!insideQuotes && currentRecord.trim()) {
                                completeLines.push(currentRecord);
                                currentRecord = '';
                            }
                        }
                        
                        // Aggiungi l'ultima riga se rimasta
                        if (currentRecord.trim()) {
                            completeLines.push(currentRecord);
                        }
                        
                        console.log(`üìã Righe ricostruite: ${completeLines.length}`);
                        
                        if (completeLines.length < 2) {
                            throw new Error('File CSV non valido - meno di 2 righe complete trovate');
                        }
                        
                        // Parse header
                        const headerLine = completeLines[0];
                        console.log(`üìã Header line: "${headerLine}"`);
                        
                        const headers = headerLine.split(';').map(h => h.trim().replace(/^"(.*)"$/, '$1'));
                        
                        console.log(`üìä Headers trovati (${headers.length}): ${headers.join(' | ')}`);
                        
                        // Verifica headers
                        const expectedHeaders = ['Item', 'CATEGORIA', 'PREZZO', 'INGREDIENTI PRINCIPALI', 'STORYTELLING'];
                        const missingHeaders = expectedHeaders.filter(h => !headers.includes(h));
                        if (missingHeaders.length > 0) {
                            console.error('‚ùå Headers mancanti:', missingHeaders);
                            throw new Error(`Headers mancanti nel CSV: ${missingHeaders.join(', ')}\n\nHeaders trovati: ${headers.join(', ')}\n\nHeaders attesi: ${expectedHeaders.join(', ')}`);
                        }
                        
                        console.log('‚úÖ Tutti gli headers richiesti sono presenti');
                        
                        // Parse dati
                        const data = [];
                        for (let i = 1; i < completeLines.length; i++) {
                            const line = completeLines[i];
                            if (!line.trim()) continue;
                            
                            // Split intelligente che rispetta le virgolette
                            const fields = [];
                            let currentField = '';
                            let inQuotes = false;
                            
                            for (let j = 0; j < line.length; j++) {
                                const char = line[j];
                                
                                if (char === '"') {
                                    inQuotes = !inQuotes;
                                } else if (char === ';' && !inQuotes) {
                                    fields.push(currentField.trim());
                                    currentField = '';
                                } else {
                                    currentField += char;
                                }
                            }
                            
                            fields.push(currentField.trim());
                            
                            // Crea oggetto riga
                            const row = {};
                            headers.forEach((header, index) => {
                                let value = fields[index] || '';
                                
                                // Rimuovi virgolette esterne
                                if (value.startsWith('"') && value.endsWith('"')) {
                                    value = value.slice(1, -1);
                                }
                                
                                // Conversione PREZZO
                                if (header === 'PREZZO' && value) {
                                    const num = parseFloat(value.replace(',', '.'));
                                    if (!isNaN(num)) value = num;
                                }
                                
                                row[header] = value;
                            });
                            
                            data.push(row);
                        }
                        
                        console.log(`‚úÖ Parsing completato: ${data.length} righe di dati`);
                        
                        return {
                            data: data,
                            meta: { fields: headers, delimiter: ';' }
                        };
                    }
                    
                    const parsedData = parseCSVCorrectly(csvContent);
                    
                    console.log('‚úÖ PARSING COMPLETATO!');
                    console.log(`üìä Campi: ${parsedData.meta.fields.join(', ')}`);
                    console.log(`üìã Righe dati: ${parsedData.data.length}`);
                    
                    // Mostra esempi primi 2 articoli
                    parsedData.data.slice(0, 2).forEach((item, i) => {
                        console.log(`\nüìÑ Articolo ${i + 1}:`);
                        console.log(`  Nome: ${item.Item}`);
                        console.log(`  Categoria: ${item.CATEGORIA}`);
                        console.log(`  Prezzo: ${item.PREZZO}`);
                        console.log(`  Ingredienti: ${item['INGREDIENTI PRINCIPALI'] ? 'S√å' : 'NO'} (${(item['INGREDIENTI PRINCIPALI'] || '').length} char)`);
                        console.log(`  Storytelling: ${item['STORYTELLING'] ? 'S√å' : 'NO'} (${(item['STORYTELLING'] || '').length} char)`);
                    });

                    // Filtra articoli validi
                    const validItems = parsedData.data.filter(item => {
                        return item.CATEGORIA && item.Item && item.PREZZO && item.PREZZO > 0;
                    });

                    if (validItems.length === 0) {
                        throw new Error('Nessun articolo valido trovato');
                    }

                    console.log(`‚úÖ Articoli validi: ${validItems.length}/${parsedData.data.length}`);

                    // Raggruppa per categoria
                    const itemsByCategory = {};
                    validItems.forEach(item => {
                        const category = item.CATEGORIA;
                        if (!itemsByCategory[category]) {
                            itemsByCategory[category] = [];
                        }
                        itemsByCategory[category].push(item);
                    });

                    // Converte nel formato app
                    const menuData = {};
                    let globalId = 1;

                    Object.entries(itemsByCategory).forEach(([category, items]) => {
                        menuData[category] = items.map(item => ({
                            id: globalId++,
                            name: item.Item,
                            price: parseFloat(item.PREZZO) || 0,
                            ingredients: item['INGREDIENTI PRINCIPALI'] || '',
                            description: item['STORYTELLING'] || '',
                            category: item.CATEGORIA
                        }));
                    });

                    console.log(`üéØ Menu finale: ${Object.keys(menuData).length} categorie, ${globalId - 1} articoli`);

                    // Salva su Firebase
                    await firebaseService.update('menuData', menuData);
                    
                    this.setState({ 
                        customMenuData: menuData,
                        syncStatus: 'üî• Menu CSV caricato!'
                    });

                    const totalItems = globalId - 1;
                    const categories = Object.keys(menuData).length;
                    const skipped = parsedData.data.length - validItems.length;
                    
                    alert(`‚úÖ MENU CSV CARICATO!\n\nüìÇ ${categories} categorie\nüçΩÔ∏è ${totalItems} articoli\n‚ö†Ô∏è ${skipped} scartati\n\nüî• Ingredienti e descrizioni inclusi!`);

                } catch (error) {
                    console.error('‚ùå ERRORE COMPLETO:', error);
                    console.error('‚ùå Stack trace:', error.stack);
                    alert(`‚ùå Errore caricamento CSV:\n\n${error.message}`);
                }
            }

            triggerCSVUpload() {
                // Crea un input file nascosto e attivalo
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.csv';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        this.loadMenuFromCSV(file);
                    }
                };
                input.click();
            }

            useDefaultMenu() {
                const confirmMsg = '‚ö†Ô∏è Tornare al menu di default?\n\nIl menu CSV personalizzato verr√† disattivato.';
                if (!window.confirm(confirmMsg)) return;

                this.setState({ 
                    customMenuData: null,
                    syncStatus: 'üî• Menu di default attivato'
                });
                
                firebaseService.update('menuData', null);
                alert('‚úÖ Menu di default riattivato!');
            }

            editTable(tableId) {
                this.setState({ editingTable: tableId });
            }
            
            async saveTableEdit(tableId, newSeats) {
                const updatedTables = this.tables.map(table => 
                    table.id === tableId 
                        ? { ...table, seats: parseInt(newSeats) || 2 }
                        : table
                );
                
                this.setState({ 
                    customTables: updatedTables,
                    editingTable: null 
                });
                
                await firebaseService.update('tables', updatedTables);
            }
            
            cancelTableEdit() {
                this.setState({ editingTable: null });
            }

            async applyTableLayout() {
                // Avvisa se ci sono ordini
                const hasActiveOrders = this.state.activeOrders.length > 0;
                const hasDraftOrders = Object.keys(this.state.orders).length > 0;
                
                if (hasActiveOrders || hasDraftOrders) {
                    const totalOrders = this.state.activeOrders.length + Object.keys(this.state.orders).length;
                    const confirmMsg = `‚ö†Ô∏è APPLICAZIONE LAYOUT!\n\nCi sono ${totalOrders} ordini aperti che verranno CANCELLATI.\n\nVuoi continuare?`;
                    
                    if (!window.confirm(confirmMsg)) {
                        return;
                    }
                }
                
                // Conserva le personalizzazioni esistenti o crea nuovi tavoli
                const currentTables = [...this.tables];
                const newTables = [];
                
                for (let i = 0; i < this.state.tableCount; i++) {
                    const existingTable = currentTables.find(t => t.number === i + 1);
                    if (existingTable) {
                        // Mantieni il tavolo esistente con i suoi posti personalizzati
                        newTables.push({ ...existingTable, id: i + 1 });
                    } else {
                        // Crea nuovo tavolo con posti di default
                        const defaultSeats = i % 3 === 0 ? 6 : i % 2 === 0 ? 4 : 2;
                        newTables.push({ id: i + 1, number: i + 1, seats: defaultSeats });
                    }
                }
                
                this.setState({ 
                    customTables: newTables,
                    editingTable: null,
                    orders: {},           // Cancella ordini in bozza
                    activeOrders: []      // Cancella ordini in cucina
                });
                
                // Aggiorna Firebase
                await firebaseService.update('tables', newTables);
                await firebaseService.update('orders', {});
                await firebaseService.update('activeOrders', []);
                
                alert(`‚úÖ LAYOUT APPLICATO!\n\n‚Ä¢ Tavoli: ${this.state.tableCount}\n‚Ä¢ Personalizzazioni mantenute\n‚Ä¢ Ordini cancellati`);
            }

            resetTables() {
                // Avvisa SEMPRE se ci sono ordini
                const hasActiveOrders = this.state.activeOrders.length > 0;
                const hasDraftOrders = Object.keys(this.state.orders).length > 0;
                
                if (hasActiveOrders || hasDraftOrders) {
                    const totalOrders = this.state.activeOrders.length + Object.keys(this.state.orders).length;
                    const confirmMsg = `‚ö†Ô∏è RESET COMPLETO!\n\nCi sono ${totalOrders} ordini aperti che verranno CANCELLATI definitivamente.\n\nQuesto include:\n- Ordini in bozza\n- Ordini in cucina\n- TUTTE le personalizzazioni dei tavoli\n\nSei SICURO di voler continuare?\n\n‚ö†Ô∏è QUESTA AZIONE NON √à REVERSIBILE!`;
                    
                    if (!window.confirm(confirmMsg)) {
                        return;
                    }
                }
                
                // RESET COMPLETO - rigenera tutto da zero
                const newTables = [];
                for (let i = 0; i < this.state.tableCount; i++) {
                    const seats = i % 3 === 0 ? 6 : i % 2 === 0 ? 4 : 2;
                    newTables.push({ id: i + 1, number: i + 1, seats: seats });
                }
                
                this.setState({ 
                    customTables: newTables,
                    editingTable: null, 
                    showSettings: false,
                    orders: {},           
                    activeOrders: []      
                });
                
                firebaseService.update('tables', newTables);
                firebaseService.update('orders', {});
                firebaseService.update('activeOrders', []);
                
                alert(`‚úÖ RESET COMPLETO ESEGUITO!\n\n‚Ä¢ Tavoli: ${this.state.tableCount}\n‚Ä¢ Tutte le personalizzazioni cancellate\n‚Ä¢ Tutti gli ordini cancellati`);
            }
